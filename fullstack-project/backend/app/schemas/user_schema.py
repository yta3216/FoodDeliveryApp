"""
This module defines the basic user schema for the application.

Any updated to the users account details should follow this schema.
"""

from enum import Enum
from pydantic import BaseModel, field_validator, EmailStr

# User role enumeration (for fixed set of roles)
class UserRole(str, Enum):
    CUSTOMER = "customer"
    RESTAURANT_MANAGER = "manager"
    ADMIN = "admin"
    DELIVERY_DRIVER = "driver"

# Base user model with common fields
class User(BaseModel):
    id: str
    email: str
    name: str
    password: str
    age: int
    gender: str
    role: UserRole
    reset_token: str | None = None  # Optional field for password reset token
    reset_token_expiry: int | None = None  # Optional field for token expiry timestamp

# Specific user models
class Customer(User):
    role: UserRole = UserRole.CUSTOMER

class RestaurantManager(User):
    role: UserRole = UserRole.RESTAURANT_MANAGER

class Admin(User):
    role: UserRole = UserRole.ADMIN

class DeliveryDriver(User):
    role: UserRole = UserRole.DELIVERY_DRIVER
    
# user_create and user_update models for input validation.
# These do not include the 'id' field since it is generated by the system.
class User_Create(BaseModel):
    email: EmailStr
    password: str
    name: str
    age: int
    gender: str
    role: UserRole

    @field_validator("email")
    @classmethod
    def validate_email(cls, v):
        if not v.strip():
            raise ValueError("Email cannot be empty")
        return v.strip()
    
    @field_validator("password")
    @classmethod
    def validate_password(cls, v):
        if len(v.strip()) < 8:
            raise ValueError("Password must be at least 8 characters long")
        return v
    
    @field_validator("name")
    @classmethod
    def validate_name(cls, v):
        if not v.strip():
            raise ValueError("Name cannot be empty")
        return v.strip()
    
    @field_validator("age")
    @classmethod
    def validate_age(cls, v):
        if v < 0 or v > 100:
            raise ValueError("Age must be between 0 and 100")
        return v
    
    @field_validator("gender")
    @classmethod
    def validate_gender(cls, v):
        allowed = {"male","female","other","prefer not to say"}
        if v.strip().lower() not in allowed:
            raise ValueError("Gender must be one of: male, female, other, prefer not to say");
        return v.strip().lower()

class User_Update(BaseModel):
    email: str
    password: str
    name: str
    age: int
    gender: str
    role: UserRole

# login request model (email + password)
class LoginRequest(BaseModel):
    email: str
    password: str

# login response model
class LoginResponse(BaseModel):
    token: str
    user_id: str
    email: str
    role: UserRole
    age: int
    gender: str
    name: str

# password reset request model, for when a user forgets their password and needs to reset it.
class Password_Reset_Request(BaseModel):
    email: str

# password reset model, for when a user has forgotten their password and needs to reset it using a token.
class Password_Reset(BaseModel):
    new_password: str
    reset_token: str

# reset password model, when a logged in user wants to change their password.
class Password_Update_When_Logged_In(BaseModel):
    email: str
    old_password: str
    new_password: str